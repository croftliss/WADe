<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
    <title>CryK Scholarly HTML</title>
    <link rel="stylesheet" href="css/scholarly.min.css">
    <script src="js/scholarly.min.js"></script>
</head>
<body prefix="schema: http://schema.org">
    <header>
        <div class="banner">
            <img src="scholarly-html.svg" width="227" height="50" alt="Scholarly HTML logo">
            <div class="status">CryK (Cryptocurrency Knowledge Manager)</div>
        </div>
        <h1>Scholarly HTML</h1>
    </header>
    <div role="contentinfo">
        <dl>
            <dt>Authors</dt>
            <dd>
                <a href="https://jumpy-bugs-a-cry-k-project.blogspot.com/">JumpyBugs</a>
                (Elisabeta Constatin
                &amp;
                Cosmin-Gabriel Cruceanu
                &amp;
                Theodor Samson)
            </dd>
            <dt>License</dt>
            <dd>
                <a href="http://creativecommons.org/licenses/by/4.0/">CC-BY</a>
            </dd>
        </dl>
    </div>
    <section typeof="sa:Abstract" id="abstract" role="doc-abstract">
        <h2>Abstract</h2>
        <p>
            This report describes the solution created by the JumpyBugs team for CryK, a WADE project. The report contains details describing the architecture of the application, technologies used for backend and frontend development, alongside a short description for its diagrams.
        </p>
    </section>
    <section id="introduction" role="doc-introduction">
        <!-- review? -->
        <h2>Introduction</h2>
      <p>
        Cryptocurrencies are incresingly popular alternatives for online payment since they enable secure online payments without 
        the use of third-party intermediaries. But before converting traditional currencies into 
        cryptocurrencies the users should search for information regarding the currency wanted. 
      </p>
      <p>
        CryK (Cryptocurrency Knowledge Manager) is a micro-service-based web application capable to show 
        and manage information regarding cryptocurrencies (e.g. name, trading symbol, total coins, block target time, 
        hashing algorithm, date launched, URL of the source code repository, URL to the official page). 
      </p>
      <p>
        This catalogue of coins will use semantic web technology. This approach takes advantage of the attendant power and 
        flexibility of representation in order to improve ease of re-use. The Web Ontology Language (OWL) will be used in this project
        in order to define a structure of knowledge for our main domain and more.
      </p>
    </section>
    <section id = "progress">
        <h2>Project progress</h2>
        <p>
            This project exceeded its initial goals and accomplished more than what was originally intended. Initially, the project was designed as a simple altcoin viewer that could produce data visualizations while fulfilling the requirements. 
            The requirements were:
            <ol><li>Manage the knowledge about existing cryptocurrencies and their (meta-)data.</li>
                <li>Implement micro-services</li>
                <li>Implement a SPARQL endpoint</li>
                <li>Exposed information available in at least HTML+RDFa and JSON-LD</li>
            </ol>
            However, by the deadline, after completing the above mentioned goals, the team was also able to incorporate a secure user management system that allows users to track their favorite coins and monitor their performance. 
            In addition, the project also features a functional SPARQL endpoint that enables users to navigate the web application's vocabulary. Even more, a basic recommandation model has been introduced, which gives hints to the user whether 
            he should buy or not in the near future a cryptocurrency. This is a clear testament to the project's success in going beyond its initial purpose and delivering a comprehensive solution to users.
        </p>
    </section>
    <section id="structure">
        <!-- review? -->
        <h2>Technologies</h2>
            <p> 
                Our project is a web application which provides interactive services that can be accessed by web browsers.
            </p>
            <p>
                <h3>Frontend</h3>
                The front end representing our catalogue of coins is built using Angular. 
            </p>
            <p>
                <h3>Backend</h3>
                The back end includes CryKAPI and CryKSemanticAPI, both written in Python using, and deployed using Flask:
                <ul>
                    <li>
                        CryKAPI utilises multiple services (CryKDatabase, CoinGECKOService and MLService). CryKDatabase utilises pymongo to ensure communication with the chosen database provider. The communication is done using JSON format for both calls and responses, moreover the responses from the MongoDB are transformed into specific models that can be easily converted into JSONs.
                        CoinGECKOService was used to further filter the coins which are exposed via the endpoints for SemanticAPI, but its main purpose it is to provide real-time data for specific coins (which are still alive), and to also provide historic data (up to 5 days). We chose to use CoinGECKO because its API is free-to-use, however we are still limited in regards to how many calls we can perform per minute.
                        CryK also offers a prediction via its MLService whether someone should invest into a specific coin (DISCLAIMER: do not invest using our model's predictions).
                    </li>
                    <li>CryKSemanticAPI utilises Ontology Query Service which uses the library rdflib in order to work with RDF and SPARQL queries. CryK handles queries on the DOACC dataset via the query system provided by rdflib or on the JSON-LD via its known properties. The JSON-LD was obtained by converting the DOACC dataset which was provided in the N-Tiples format. JSON-LD provided easier acces and better control over the dataset.</li>
                </ul>
            </p>  
    </section>
    <section id="Data">
        <h2>Data</h2>
        <section id = "data structures">
        <h3>Data structures</h3>
        <p>In order to manage the data within our project, we have made use of 4 models which are aligned to the project's needs and will be illustrated down below:</p>
        <img class="image" src="images/Cryptocurrency_model.png" width="200" height="360">
        <img class="image" src="images/Portfolio_model.png" width="140" height="125">
        <img class="image" src="images/Profile_model.png" width="125" height="225">
        <img class="image" src="images/User_model.png" width="115" height="100">
        <p>The Cryptocurrency class will be used with the data received from DOACC in order to populate the fields for each cryptocurrency available in our project.</p>
        <p>The Portfolio class is used to keep track of a user's coin portfolio, including the different types of coins they own and the number of each type.</p>
        <p>The Profile class can be used to store and manage information about a user's personal profile, including their contact information, location, and personal details. This information can be used by other classes or applications to personalize the user experience and provide relevant content.</p>
        <p>The User class is used in registration and login processes, where a user is required to provide their email address and password to create an account or access their existing account. The email and password combination is verified against a database to ensure the user is authorized to access the system.</p>
        <p>
            All of the above classes can be easily exported to JSON format.
        </p>
        </section>
        <section id = "external data">
            <h3>External data</h3>
            <p>The integration of the DOACC data and CoinGecko API has enabled us to deliver a powerful and informative system for users interested in the cryptocurrency market.
                This information includes the symbol of the altcoin, its current price, and an illustration of the coin. To make this information more accessible and easier to work with, we have transformed the N-Triples received from 
                the DOACC into JSON-LD. This transformation has increased the data flexibility within our system and allows us to easily access and manipulate the information as needed.
            </p>
            <h4>CoinGecko</h4>
            <p>CoinGecko is a cryptocurrency data platform that provides real-time market data, charts, and insights for over 8,000 cryptocurrencies. By reaching out to CoinGecko's API, we can access up-to-date information about the price 
                of different cryptocurrencies. This integration helps us provide valuable insights and information to our users about the cryptocurrency market. With the use of CoinGecko's API, we enhance the functionality of the project and 
                make it more informative for our users. </p>
            <h4>DOACC data</h4>
            <p>The DOACC is a database of information regarding altcoins, which are cryptocurrencies other than Bitcoin. This database includes facts such as the name, trading symbol, total number of coins, target time for blocks, hashing algorithm used, date of launch, and URL for the source code repository.
                We have integrated in our project the dataset that they provide, which is in n-triple format, in order to offer various information about the altcoins that are also available in the CoinGecko API.
            </p>
        </section>
        <section id = "Data transformations">
            <h3>Data transformations</h3>
            <p>The data received from DOACC in N-TRIPLES format was transformed into a JSON-LD format to make it more manageable and to move closer to the ultimate goal of exposing data in JSON-LD and HTML+RDFa. For efficient management of the data, 
                it was often converted back to simple JSON, facilitating communication between the front-end and back-end. If it is desired to view the data in either JSON-LD or HTML+RDFa, it is simple to make a call to our API at
                *<i>/ontology/api/"format"/getCryptocurrenciesByName</i>* and specify the desired format. This process is illustrated in the diagram below:
                <img src="images/data_transformation.png"/>
            </p>
        </section>
    </section>
    <section id="architecture">
        <h2>Architecture</h2>
        <p>
            The project consists of various components, including an Angular-based frontend and a node.js server, as well as a Python-based backend utilizing Flask. The backend features two APIs - one for SPARQL queries and another for managing 
            user accounts, coins, and other related data. These services are designed as micro-services, running concurrently on separate ports and managing data from various sources. User-specific information is stored on MongoDB Atlas for availability and manageability, 
            while information about altcoins is stored within the server in for reduced latency.</p>
        <section id="diagram">
            <h3>General diagram</h3>
            <p>
                The application follows a very simple architecture, from a frontend client, the actions done by the user call different endpoints in 2 APIs, one with a more general purpose, and the other one, a semantic API that that utilises a wrapper for SPARQL that has a queries ready to be used on our onthology obtained from <a href="https://doacc.github.io/">DOACC</a>.
            </p>
            <img class="image" src="images/Architecture.png" width="660" height="726">
        </section>
    </section>
    <section id="model">
        <h2>Cryptocurrency buying recommender</h2>
        The model was created using the SequentialModel from <a href="https://www.tensorflow.org/">Tensorflow</a>. The model features the following layers:
        <ol>
            <li>The first layer adds a new axis to the input that will be used to obtain the predictions;</li>
            <li>The second layer creates a convolutional kernel with the input layer over the spatial dimension to produce a tensor with the given dimensions (in our case 128 filters) and a kernel of size 5x5;</li>
            <li>The third layer creates a fully dense layer in order to take into account all the values produced by the previous layer and "classify" them into 128 classes;</li>
            <li>The last layer does the same thing as the previous one, but it produces 2 values that correspond to the predicted values for the input coin for the next 2 days</li>
        </ol>
        <img class="image" src="images/ML_model.png" width="600" height="250"><br />
        We trained 3 such models, each based on the historical prices of different cryptocurrencies (ETH, BTC and DOGE). Based on the output of each model, the percetage obtained after calling the model produces a percentage that indicates the confidence that the model has whether the coin would raise or not in price. As we said previously, this does not mean that the coin will actually grow in price, and users should not invest based on that percentage.
        <img class="image" src="images/prediction-doge.png" width="600" height="250"><br />
        In the image above, the blue dots represent the real progress through which Dogecoin went through, and with orange dots we have the predicted values for Dogecoin for the next half a year.
        The model above has a loss of 0.0590. <img class="image" src="images/loss.png" width="100" height="25">
    </section>
    <section id="ontology">
        <h2>Ontology</h2>
        <p>
            The choice of the ontology language to utilize in a particular situation must be made before beginning to create an ontology-based system. For our project, we have used the <u>Ontology Web Language</u> (OWL) format for modeling our data, which was acquired through the <a href="https://doacc.github.io/">DOACC</a> project and these files came in the above mentioned extension. The tool used to display the ontologies and extract some metrics and previews was <a href="https://protege.stanford.edu/">Protege</a>, a free, open-source ontology editor.
        </p>
        <p>            
            The dataset that we gathered was converted through a custom script from the n-triples format to json-ld to ease access and readability.
        </p>
        <h3>DOACC</h3>
        <p>
            The DOACC ontology model is described as in the following illustrations:
        </p>
        <ul>
            <li>The complete graph: <img src="images/doacc_graph.png"/></li>
            <li>The arc relations between entities: <br> <img src="images/doacc_arc_types.png"/></li>
            <li>The prefixes: <img src="images/doacc_prefixes.png"/></li>
            <li>The most relevant metrics of the vocabulary: <img src="images/doacc_metrics.png"/></li>
            <li>The data managed by our system (in terms of the cryptocurrency information handled) comes first of all from the properties of the DOACC ontology: <img src="images/dataset_visualizer.png"/></li>
        </ul>
    </section>
    <section id = "knowledge">
        <h2>Knowledge usage</h2>
        <p> The knowledge model utilized in our project is derived from the DOACC project and stored in N-TRIPLES format. This data was deemed comprehensive enough for our purposes and covered all the information necessary for us to build upon it. 
            To make the data more readable and manageable, we converted it from N-TRIPLES to json-ld, which also met the requirements of the project. The json-ld data includes details such as the protocol used by the altcoin, its preferred label, website, and more. 
            However, some coins lacked complete information, so we had to be flexible in our data retrieval and parsing process. In addition to the DOACC project, we also made use of other knowledge bases such as SKOS and DC to retrieve descriptions 
            and preferred labels of the coins.
            Our semantic API provides various endpoints that allow us to retrieve specific data based on our needs, such as getting coins based on their protocol (PoW or PoS), retrieving a filtered list of coins based on their name, or getting the image associated with 
            a single coin. All this information is integrated into our web application and can be accessed through the Cryptocurrencies tab. <img src="images/Cryptocurrencies_tab.png"/> To make data more accessible, we also expose a sparql endpoint which can be used 
            within the project through the Sparql tab. Below, a brief example of a request and response for an endpoint call: <img src="images/Cryptocurrency_by_name.png"/>
        </p>
        <p>Valid html + RDFa generation: <img src="images/valid_rdfa.png" width="1100" length="1000"/> Valid jsonLD generation: <img src="images/valid_jsonld.png"/></p>
    </section>
    <section id="api">
        <h2>APIs</h2>
        JumpyBugs implemented the APIs using Flask, due to its simplicity in launching a very simple server, capable of accepting multiple requests of different methods (POST, GET), accessing the request's data, handling user cookies, and having an easy way in which responses can be send back as JSON.
        <section id="semantic-api">
            <h3>CryKSemanticAPI</h3>
            <p>
                This API handles requests for obtaining information about cryptocurrencies from the JSON-LD file converted from the DOACC dataset. The API calls the Ontology Wrapper that has methods for obtaining all the cryptocurrencies or filtered based on the name or protocol. The cryptocurrencies are firstly filtered by the coins which CoinGECKO can actually handle, and then via the filters required by the request. The API offers the information in different formats, JSON, JSON-LD or HTML-RDFa, all of which were validated using online tools.<br />
                As an example, let's see how the following route works:<br />
                <img src="images/route-semantic-api.png" />
                The route takes as parameter in which format the response should be returned in (JSON-LD or HTML RDFa), and the takes the coin names from the request body, and performs the query on the JSON-LD from DOACC. A sample response for that endpoint is the following, as validated for JSON-LD:<br />
                <img src="images/json-ld-bitcoin.png" />
            </p>
        </section>
        <section id="cryk-api">
            <h3>CryK API</h3>
            <p>
                The CryK API works as a multi-purpose API handling user login, user portfolio and user profile. The API also handles the images for the cryptocurrencies, keeping our frontend lightweight. Most of the routes are protected using the token obtain from Google OAuth or by the user's id, one of which must be present as a header for the request. The responses are much simpler for this API, as it returns JSONs.
            </p>
        </section>
    </section>
    <section id="article">
      <h3>Use cases</h3>
      <p>
        Cryptocurrencies have been designed to address a variety of issues prevalent across multiple industries. These digital assets can be used in several ways, including:
      </p>
      <p>
        <ul>
            <li>Trading</li>
            <li>Online Payments</li>
            <li>Exchange</li>
        </ul>
      </p>
      <p>Our project is focused on providing support to users with their digital assets. One of our key objectives is to enable users to effectively track and manage their digital assets. Additionally, our project also aims to educate and guide users 
        towards making informed decisions in the cryptocurrency market. We strive to provide the necessary tools and information to help users identify the best opportunities and make the most of their investments in the cryptocurrency space.</p>
        <h3>Task flows</h3>
        <h4>Login/Register</h4>
        <p>In order for the user to gain full access to our web application, it is mandatory to create an account first. This can be achieved through either OAuth2 with google, or with our custom login/register. Our authentication service is designed to enhance 
            security by implementing a secure method for storing and validating user credentials. The process involves the use of a combination of a hash and salt on the password to generate a unique and encrypted representation of the password. This ensures that 
            even if the password is compromised, the attacker would not be able to obtain the actual password, thus providing an extra layer of security to the user's account. Upon successful login, the user's session is maintained either through a JWT 
            (if the option chosen is OAuth2) or via a session ID cookie.</p>
            <img src="images/Login_step.png"/>
        <h4>General</h4>
        <p>The following actions are available for the user:
            <ul>
                <li>Updating their personal profile.</li>
                <li>Managing their wallet to monitor portfolio performance.</li>
                <li>Accessing cryptocurrency information, such as price, symbol, and protocol.</li>
                <li>Performing SPARQL queries on available RDF data.</li>
                <li>Visualizing the comparative performance of altcoins in various formats.</li> 
                <li>See how the most important coins fare and a quick price prediction for the cryptocurrencies</li>
            </ul>
            <img src="images/General_overview.png"/>
        </p>
    </section>
    <section id="visualizations-of-data">
        <h2>Visualizations of Data</h2>
        <p>
            “Data visualization is expert storytelling” (Murray, 2013). CryK exists for a better way of showing, managing and understanding various information about cryptocurrencies so people (and machines) make better decisions about their payments, investment and financial decisions overall.
            In order to help people see, interact with, and better understand data, we will provide different types of illustrations for augmenting cognition. 
            
        </p>
        <h3>Piecharts</h3>
        <img src="images/pieChart.png"/>
        <h5>Barcharts</h5>
        <img src="images/barChart.png"/>
    </section>
    <section id="linked-data-principles">
        <h2>Linked Data principles</h2>
        <p>
            Our implementation follows the four rules of the Linked Data Initiative:
            <ol>
                <li>Use URIs as names for things ✓</li>
                <li>Use HTTP URIs so that people can look up those names ✓</li>
                <li>When someone looks up a URI, provide useful information, using the standards (RDF*, SPARQL) ✓</li>
                <li>Include links to other URIs. so that they can discover more things. ✓</li>
            </ol>
        </p>
        <p>
            We are using HTTP URIs for every thing presented on the website, so a person or a machine can explore more data. We are also using them in order to identify resources by exposing several endpoints in our API.
            As for the format and service standards, we are using the OWL format, which defines the ontology, n-triples and json-ld as formats for datasets and services, and moreover, expose a SPARQL service in order to provide a way of querying our database. 
            When clicking on an altcoin, we also included links to other related crypto currencies.
        </p>
    </section>
    <section role="doc-biblioref" id="references">
        <h2>References</h2>
        <ul>
            <li><a href="https://www.dbpedia.org/">DBpedia</a></li>
            <li><a href="https://profs.info.uaic.ro/~busaco/teach/courses/wade/web-film.html">https://profs.info.uaic.ro/~busaco/teach/courses/wade/web-film.html</a></li>
            <li><a href="https://protege.stanford.edu/">Protégé</a></li>
            <li><a href="https://doacc.github.io/">DOACC</a></li>
            <li><a href="https://www.tensorflow.org/">Tensorflow</a></li>
            <li><a href="https://json-ld.org/#developers">JSON-LD</a></li>
            <li><a href="https://json-ld.org/playground/">JSON-LD Playground</a></li>
            <li><a href="https://rdfa.info/play/">HTML+RDFa validator</a></li>
        </ul>
    </section>
</body>
</html>
